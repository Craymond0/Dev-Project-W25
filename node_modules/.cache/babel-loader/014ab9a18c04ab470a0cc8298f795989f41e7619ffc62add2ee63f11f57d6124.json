{"ast":null,"code":"import { WalletConnectionError, isVersionedTransaction } from '@solana/wallet-adapter-base';\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { UniversalProvider } from '@walletconnect/universal-provider';\nimport { parseAccountId } from '@walletconnect/utils';\nimport { createAppKit } from '@reown/appkit/core';\nimport { solana, solanaDevnet, solanaTestnet } from '@reown/appkit/networks';\nimport base58 from 'bs58';\nimport { WalletConnectRPCMethods } from './constants.js';\nimport { ClientNotInitializedError } from './errors/ClientNotInitializedError.js';\nimport { WalletConnectFeatureNotSupportedError } from './errors/WalletConnectNotSupportedError.js';\nimport { getConnectParams, getDefaultChainFromSession } from './utils.js';\nexport class WalletConnectWallet {\n  _UniversalProvider;\n  _session;\n  _modal;\n  _projectId;\n  _network;\n  _ConnectQueueResolver;\n  constructor(config) {\n    this.initClient(config.options);\n    this._network = config.network;\n    if (!config.options.projectId) {\n      throw Error('WalletConnect Adapter: Project ID is undefined');\n    }\n    this._projectId = config.options.projectId;\n  }\n  async connect() {\n    if (!this._UniversalProvider) {\n      await new Promise(res => {\n        this._ConnectQueueResolver = res;\n      });\n    }\n    if (!this._UniversalProvider) {\n      throw new Error(\"WalletConnect Adapter - Universal Provider was undefined while calling 'connect()'\");\n    }\n    if (this._UniversalProvider.session) {\n      this._session = this._UniversalProvider.session;\n      const defaultNetwork = getDefaultChainFromSession(this._session, this._network);\n      this._network = defaultNetwork;\n      this._UniversalProvider.setDefaultChain(defaultNetwork);\n      return {\n        publicKey: this.publicKey\n      };\n    }\n    await this.initModal();\n    const params = getConnectParams(this._network);\n    this._modal?.open();\n    const session = await this._UniversalProvider?.connect(params);\n    this._modal?.close();\n    this._session = session;\n    if (!session) {\n      throw new WalletConnectionError();\n    }\n    const defaultNetwork = getDefaultChainFromSession(session, this._network);\n    this._network = defaultNetwork;\n    this._UniversalProvider?.setDefaultChain(defaultNetwork);\n    return {\n      publicKey: this.publicKey\n    };\n  }\n  async disconnect() {\n    if (this._UniversalProvider?.session) {\n      await this.initModal();\n      if (!this._modal) {\n        throw Error('WalletConnect Adapter -Modal is undefined: unable to disconnect');\n      }\n      await this.client.disconnect();\n      // await this._modal.disconnect()\n      this._session = undefined;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  get client() {\n    if (this._UniversalProvider) {\n      return this._UniversalProvider;\n    }\n    throw new ClientNotInitializedError();\n  }\n  get session() {\n    if (!this._session) {\n      throw new ClientNotInitializedError();\n    }\n    return this._session;\n  }\n  get publicKey() {\n    if (this._UniversalProvider?.session && this._session) {\n      const {\n        address\n      } = parseAccountId(this._session?.namespaces['solana']?.accounts[0] ?? '');\n      return new PublicKey(address);\n    }\n    throw new ClientNotInitializedError();\n  }\n  async signTransaction(transaction) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signTransaction);\n    const isVersioned = isVersionedTransaction(transaction);\n    const legacyTransaction = isVersioned ? {} : transaction;\n    const {\n      signature,\n      transaction: signedSerializedTransaction\n    } = await this.client.client.request({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signTransaction,\n        params: {\n          /*\n           * Passing ...legacyTransaction is deprecated.\n           * All new clients should rely on the `transaction` parameter.\n           * The future versions will stop passing ...legacyTransaction.\n           */\n          ...legacyTransaction,\n          // New base64-encoded serialized transaction request parameter\n          transaction: this.serialize(transaction)\n        }\n      }\n    });\n    if (signedSerializedTransaction) {\n      return this.deserialize(signedSerializedTransaction, isVersioned);\n    }\n    transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n    return transaction;\n  }\n  async signMessage(message) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signMessage);\n    const {\n      signature\n    } = await this.client.client.request({\n      // The network does not change the output of message signing, but this is a required parameter for SignClient\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signMessage,\n        params: {\n          pubkey: this.publicKey.toString(),\n          message: base58.encode(message)\n        }\n      }\n    });\n    return base58.decode(signature);\n  }\n  async signAndSendTransaction(transaction) {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAndSendTransaction);\n    const {\n      signature\n    } = await this.client.client.request({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signAndSendTransaction,\n        params: {\n          transaction: this.serialize(transaction)\n        }\n      }\n    });\n    return signature;\n  }\n  async signAllTransactions(transactions) {\n    try {\n      this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAllTransactions);\n      const serializedTransactions = transactions.map(transaction => this.serialize(transaction));\n      const {\n        transactions: serializedSignedTransactions\n      } = await this.client.client.request({\n        chainId: this._network,\n        topic: this.session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signAllTransactions,\n          params: {\n            transactions: serializedTransactions\n          }\n        }\n      });\n      return transactions.map((transaction, index) => {\n        if (isVersionedTransaction(transaction)) {\n          return this.deserialize(serializedSignedTransactions[index] ?? '', true);\n        }\n        return this.deserialize(serializedSignedTransactions[index] ?? '');\n      });\n    } catch (error) {\n      if (error instanceof WalletConnectFeatureNotSupportedError) {\n        const promises = transactions.map(transaction => this.signTransaction(transaction));\n        const signedTransactions = await Promise.all(promises);\n        return signedTransactions;\n      }\n      throw error;\n    }\n  }\n  async initClient(options) {\n    const provider = await UniversalProvider.init(options);\n    this._UniversalProvider = provider;\n    if (this._ConnectQueueResolver) {\n      this._ConnectQueueResolver(true);\n    }\n  }\n  async initModal() {\n    if (this._modal) {\n      return;\n    }\n    if (!this._UniversalProvider) {\n      throw new Error('WalletConnect Adapter - cannot init modal when Universal Provider is undefined');\n    }\n    this._modal = createAppKit({\n      projectId: this._projectId,\n      universalProvider: this._UniversalProvider,\n      networks: [solana, solanaDevnet, solanaTestnet],\n      manualWCControl: true\n    });\n  }\n  serialize(transaction) {\n    return Buffer.from(transaction.serialize({\n      verifySignatures: false\n    })).toString('base64');\n  }\n  deserialize(serializedTransaction, versioned = false) {\n    if (versioned) {\n      return VersionedTransaction.deserialize(Buffer.from(serializedTransaction, 'base64'));\n    }\n    return Transaction.from(Buffer.from(serializedTransaction, 'base64'));\n  }\n  checkIfWalletSupportsMethod(method) {\n    if (!this.session.namespaces['solana']?.methods.includes(method)) {\n      throw new WalletConnectFeatureNotSupportedError(method);\n    }\n  }\n}","map":{"version":3,"names":["WalletConnectionError","isVersionedTransaction","PublicKey","Transaction","VersionedTransaction","UniversalProvider","parseAccountId","createAppKit","solana","solanaDevnet","solanaTestnet","base58","WalletConnectRPCMethods","ClientNotInitializedError","WalletConnectFeatureNotSupportedError","getConnectParams","getDefaultChainFromSession","WalletConnectWallet","_UniversalProvider","_session","_modal","_projectId","_network","_ConnectQueueResolver","constructor","config","initClient","options","network","projectId","Error","connect","Promise","res","session","defaultNetwork","setDefaultChain","publicKey","initModal","params","open","close","disconnect","client","undefined","address","namespaces","accounts","signTransaction","transaction","checkIfWalletSupportsMethod","isVersioned","legacyTransaction","signature","signedSerializedTransaction","request","chainId","topic","method","serialize","deserialize","addSignature","Buffer","from","decode","signMessage","message","pubkey","toString","encode","signAndSendTransaction","signAllTransactions","transactions","serializedTransactions","map","serializedSignedTransactions","index","error","promises","signedTransactions","all","provider","init","universalProvider","networks","manualWCControl","verifySignatures","serializedTransaction","versioned","methods","includes"],"sources":["/Users/aaryaupadhyay/umich-prediction-market/node_modules/@walletconnect/solana-adapter/src/core.ts"],"sourcesContent":["import { WalletConnectionError, isVersionedTransaction } from '@solana/wallet-adapter-base'\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js'\nimport type { SessionTypes, SignClientTypes } from '@walletconnect/types'\nimport { UniversalProvider } from '@walletconnect/universal-provider'\nimport { parseAccountId } from '@walletconnect/utils'\nimport { createAppKit } from '@reown/appkit/core'\nimport { solana, solanaDevnet, solanaTestnet } from '@reown/appkit/networks'\n\nimport base58 from 'bs58'\n\nimport type { AppKit } from '@reown/appkit/core'\n\n\nimport { WalletConnectRPCMethods } from './constants.js'\nimport type { WalletConnectChainID } from './constants.js'\nimport { ClientNotInitializedError } from './errors/ClientNotInitializedError.js'\nimport { WalletConnectFeatureNotSupportedError } from './errors/WalletConnectNotSupportedError.js'\nimport type {\n  UniversalProviderType,\n  WalletConnectWalletAdapterConfig,\n  WalletConnectWalletInit\n} from './types.js'\nimport { getConnectParams, getDefaultChainFromSession } from './utils.js'\n\nexport class WalletConnectWallet {\n  private _UniversalProvider: UniversalProviderType | undefined\n  private _session: SessionTypes.Struct | undefined\n  private _modal: AppKit | undefined\n  private _projectId: string\n  private _network: WalletConnectChainID\n  private _ConnectQueueResolver: ((value: unknown) => void) | undefined\n\n  constructor(config: WalletConnectWalletAdapterConfig) {\n    this.initClient(config.options)\n    this._network = config.network\n\n    if (!config.options.projectId) {\n      throw Error('WalletConnect Adapter: Project ID is undefined')\n    }\n    this._projectId = config.options.projectId\n  }\n\n  async connect(): Promise<WalletConnectWalletInit> {\n    if (!this._UniversalProvider) {\n      await new Promise(res => {\n        this._ConnectQueueResolver = res\n      })\n    }\n    if (!this._UniversalProvider) {\n      throw new Error(\n        \"WalletConnect Adapter - Universal Provider was undefined while calling 'connect()'\"\n      )\n    }\n\n    if (this._UniversalProvider.session) {\n      this._session = this._UniversalProvider.session\n      const defaultNetwork = getDefaultChainFromSession(\n        this._session,\n        this._network\n      ) as WalletConnectChainID\n      this._network = defaultNetwork\n      this._UniversalProvider.setDefaultChain(defaultNetwork)\n\n      return {\n        publicKey: this.publicKey\n      }\n    }\n    await this.initModal()\n    const params = getConnectParams(this._network)\n    this._modal?.open()\n    const session = await this._UniversalProvider?.connect(params)\n    this._modal?.close()\n    this._session = session\n    if (!session) {\n      throw new WalletConnectionError()\n    }\n    const defaultNetwork = getDefaultChainFromSession(\n      session,\n      this._network\n    ) as WalletConnectChainID\n    this._network = defaultNetwork\n    this._UniversalProvider?.setDefaultChain(defaultNetwork)\n\n    return { publicKey: this.publicKey }\n  }\n\n  async disconnect() {\n    if (this._UniversalProvider?.session) {\n      await this.initModal()\n      if (!this._modal) {\n        throw Error('WalletConnect Adapter -Modal is undefined: unable to disconnect')\n      }\n      await this.client.disconnect()\n      // await this._modal.disconnect()\n      this._session = undefined\n    } else {\n      throw new ClientNotInitializedError()\n    }\n\n  }\n\n  get client(): UniversalProviderType {\n    if (this._UniversalProvider) {\n      return this._UniversalProvider\n    }\n    throw new ClientNotInitializedError()\n  }\n\n  get session(): SessionTypes.Struct {\n    if (!this._session) {\n      throw new ClientNotInitializedError()\n    }\n\n    return this._session\n  }\n\n  get publicKey(): PublicKey {\n    if (this._UniversalProvider?.session && this._session) {\n      const { address } = parseAccountId(this._session?.namespaces['solana']?.accounts[0] ?? '')\n\n      return new PublicKey(address)\n    }\n    throw new ClientNotInitializedError()\n  }\n\n  async signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T> {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signTransaction)\n\n    const isVersioned = isVersionedTransaction(transaction)\n\n    const legacyTransaction = isVersioned ? {} : transaction\n\n    const { signature, transaction: signedSerializedTransaction } =\n      await this.client.client.request<{\n        signature: string\n        transaction?: string\n      }>({\n        chainId: this._network,\n        topic: this.session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signTransaction,\n          params: {\n            /*\n             * Passing ...legacyTransaction is deprecated.\n             * All new clients should rely on the `transaction` parameter.\n             * The future versions will stop passing ...legacyTransaction.\n             */\n            ...legacyTransaction,\n            // New base64-encoded serialized transaction request parameter\n            transaction: this.serialize(transaction)\n          }\n        }\n      })\n\n    if (signedSerializedTransaction) {\n      return this.deserialize(signedSerializedTransaction, isVersioned) as T\n    }\n\n    transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)))\n\n    return transaction\n  }\n\n  async signMessage(message: Uint8Array): Promise<Uint8Array> {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signMessage)\n\n    const { signature } = await this.client.client.request<{\n      signature: string\n    }>({\n      // The network does not change the output of message signing, but this is a required parameter for SignClient\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signMessage,\n        params: {\n          pubkey: this.publicKey.toString(),\n          message: base58.encode(message)\n        }\n      }\n    })\n\n    return base58.decode(signature)\n  }\n\n  async signAndSendTransaction<T extends Transaction | VersionedTransaction>(\n    transaction: T\n  ): Promise<string> {\n    this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAndSendTransaction)\n\n    const { signature } = await this.client.client.request<{\n      signature: string\n    }>({\n      chainId: this._network,\n      topic: this.session.topic,\n      request: {\n        method: WalletConnectRPCMethods.signAndSendTransaction,\n        params: { transaction: this.serialize(transaction) }\n      }\n    })\n\n    return signature\n  }\n\n  async signAllTransactions<T extends Transaction | VersionedTransaction>(\n    transactions: T[]\n  ): Promise<T[]> {\n    try {\n      this.checkIfWalletSupportsMethod(WalletConnectRPCMethods.signAllTransactions)\n\n      const serializedTransactions = transactions.map(transaction => this.serialize(transaction))\n\n      const { transactions: serializedSignedTransactions } = await this.client.client.request<{\n        transactions: string[]\n      }>({\n        chainId: this._network,\n        topic: this.session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signAllTransactions,\n          params: { transactions: serializedTransactions }\n        }\n      })\n\n      return transactions.map((transaction, index) => {\n        if (isVersionedTransaction(transaction)) {\n          return this.deserialize(serializedSignedTransactions[index] ?? '', true)\n        }\n\n        return this.deserialize(serializedSignedTransactions[index] ?? '')\n      }) as T[]\n    } catch (error) {\n      if (error instanceof WalletConnectFeatureNotSupportedError) {\n        const promises = transactions.map(transaction => this.signTransaction(transaction))\n        const signedTransactions = await Promise.all(promises)\n\n        return signedTransactions\n      }\n\n      throw error\n    }\n  }\n\n  async initClient(options: SignClientTypes.Options) {\n    const provider = await UniversalProvider.init(options)\n    this._UniversalProvider = provider\n    if (this._ConnectQueueResolver) {\n      this._ConnectQueueResolver(true)\n    }\n  }\n\n  async initModal() {\n    if (this._modal) {\n      return\n    }\n    if (!this._UniversalProvider) {\n      throw new Error(\n        'WalletConnect Adapter - cannot init modal when Universal Provider is undefined'\n      )\n    }\n\n\n    this._modal = createAppKit({\n      projectId: this._projectId,\n      universalProvider: this._UniversalProvider,\n      networks: [solana, solanaDevnet, solanaTestnet],\n      manualWCControl: true\n    })\n  }\n\n  private serialize(transaction: Transaction | VersionedTransaction): string {\n    return Buffer.from(transaction.serialize({ verifySignatures: false })).toString('base64')\n  }\n\n  private deserialize(\n    serializedTransaction: string,\n    versioned = false\n  ): Transaction | VersionedTransaction {\n    if (versioned) {\n      return VersionedTransaction.deserialize(Buffer.from(serializedTransaction, 'base64'))\n    }\n\n    return Transaction.from(Buffer.from(serializedTransaction, 'base64'))\n  }\n\n  private checkIfWalletSupportsMethod(method: WalletConnectRPCMethods) {\n    if (!this.session.namespaces['solana']?.methods.includes(method)) {\n      throw new WalletConnectFeatureNotSupportedError(method)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}